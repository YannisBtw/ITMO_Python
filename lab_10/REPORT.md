# Лабораторная работа 10 - Оптимизация вычислений (потоки, процессы, Cython, noGIL)

## Цель
Исследовать методы оптимизации вычислительного кода, используя потоки, процессы, Cython и отпускание GIL, на основе сравнения времени вычисления численного интеграла методом прямоугольников.

## Итерация 1 - чистый Python
- Функция `integrate()` оформлена docstring (PEP 257) и аннотациями типов (PEP 484) - файл `integrate_base.py`.
- В docstring встроены примеры `doctest`.
- Добавлены unit-тесты (pytest и unittest) - каталог `tests/`.
- Замеры времени: `iteration1_pure_python.py` и общий прогон `bench_all.py`.

## Итерация 2 - потоки
- Реализована функция `integrate_async()` (ThreadPoolExecutor) - файл `iteration2_threads.py`.
- Замеры для 2, 4, 6, 8 потоков.

Вывод: для CPU-bound кода на чистом Python потоки почти не ускоряют вычисления из-за GIL.

## Итерация 3 - процессы
- Реализована функция `integrate_async_processes()` (ProcessPoolExecutor) - файл `iteration3_processes.py`.
- Замеры для 2, 4, 6, 8 процессов.

Вывод: процессы дают реальный параллелизм и ускорение, но имеют накладные расходы.

## Итерация 4 - профилирование и Cython
### Профилирование
Файл `profile_integrate.py` строит профиль выполнения и сохраняет `profile.pstats`.

### Cython-оптимизация
Модуль `cython_mod/integrate_cy.pyx` содержит:
- `integrate_sin`, `integrate_cos`, `integrate_poly2` - C-level варианты (минимум взаимодействия с Python/C-API)
- `integrate_pycall` - цикл ускорен, но вызов `f(x)` остается Python-вызовом в каждой итерации.

### annotate=True
Сборка с HTML-аннотацией:
```bash
CYTHON_ANNOTATE=1 python setup.py build_ext --inplace
```

## Итерация 5 - noGIL
Модуль `cython_mod/integrate_nogil.pyx`:
- `integrate_sin_nogil` - отпускание GIL и распараллеливание через `prange` (OpenMP).
- Замеры для 2, 4, 6 потоков и сравнение с процессами + чистый Python.

## Доп. вопрос: мьютексы/семафоры
Обычно не нужны:
- каждая задача считает локальную сумму
- итоговая сумма складывается после завершения задач
- блокировки внутри цикла ухудшают производительность

## Доп. вопрос: Python 3.14 и GIL
В стандартном CPython по умолчанию используется GIL, поэтому вывод про потоки (итерация 2) сохраняется.
Если используется экспериментальная сборка/режим без GIL, потоки могут начать ускорять CPU-bound код - тогда замеры нужно повторить.
