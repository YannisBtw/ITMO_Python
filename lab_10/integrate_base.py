from __future__ import annotations

from typing import Callable


def integrate(
        f: Callable[[float], float],
        a: float,
        b: float,
        *,
        n_iter: int = 100_000
) -> float:
    """
    Численно вычисляет интеграл функции на отрезке [a, b]
    методом левых прямоугольников.

    Отрезок [a, b] разбивается на n_iter равных частей.
    В каждой точке считается значение функции в левом конце
    подотрезка и суммируется площадь прямоугольников.

    Параметры
    ----------
    f : Callable[[float], float]
        Интегрируемая функция.
    a : float
        Левая граница интегрирования.
    b : float
        Правая граница интегрирования.
    n_iter : int, optional
        Число итераций (прямоугольников), по умолчанию 100000.

    Возвращает
    ----------
    float
        Приближенное значение интеграла.

    Ограничения метода
    ------------------
    - Метод имеет первый порядок точности: ошибка обычно убывает как O(1/n_iter)
      для достаточно гладких функций.
    - Для разрывных/сильно осциллирующих функций может потребоваться очень большое n_iter.
    - При a > b результат будет отрицательным (ориентация интеграла сохраняется).

    Примеры (doctest)
    -----------------
    >>> import math
    >>> round(integrate(math.cos, 0.0, math.pi, n_iter=200_000), 6)
    0.0

    >>> # ∫_0^1 (x^2 + 2x + 1) dx = 7/3
    >>> abs(integrate(lambda x: x*x + 2*x + 1, 0.0, 1.0, n_iter=200_000) - 7/3) < 1e-4
    True
    """
    if not isinstance(n_iter, int) or n_iter <= 0:
        raise ValueError("n_iter должно быть положительным целым числом")

    acc = 0.0
    step = (b - a) / n_iter
    for i in range(n_iter):
        acc += f(a + i * step) * step
    return acc
